# -*- coding: utf-8 -*-
"""round_robin

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CdN7J8IknFWZBbYnVZMK9CkFc-AlRBEy
"""

'''
Program: round_robin.py. 

Programmer: Omar Shatrat

Date: 11/11/2022

Description: Program that makes a round robin schedule for a list of names.

'''

class RoundRobin:
  # The round robin class contains methods that initialize a list of names and return rounds according to schedule. 
  # The list of names is taken, 'bye' is added if needed, and then the list if split and pairs are made.
  # Following this, the list is shifted and the process repeats. The program returns pairs before each list shift.

  def __init__(self, nameList):
    # The list of names is taken for parameters, 'bye' is added to a copy of the list if needed

    self.nameList = nameList
    
    if len(self.nameList) % 2 != 0:
      self.nameList.append('bye')
      self.names = list(self.nameList)
    else:
      self.names = list(self.nameList)
    
    self.cnt = -1 

  def generate_round(self):
    # No parameters are taken here, and divide_chunks divides a list into equal parts while set_cnt increments a count value to print the subsequent rounds after one round.
    # We have an empty list to store pairs, and the we split the list of names and append together the relevant pairs
    # The list of pairs is the return value for each round
    
    def divide_chunks(l, n):
      # looping till length l
      for i in range(0, len(l), n):
        yield l[i:i + n]
    
    def set_cnt():
      self.cnt += 1
    
    pairs = []
    for i in range(len(self.names)-1):
      split = int(len(self.names)/2)
      l1 = self.names[0:split]
      l2 = self.names[split:]
      l2.reverse()
      
      for i in range(len(l1)):
        pairs.append((l1[i], l2[i]))
      
      self.names = [self.names[0]] + [self.names[-1]] + self.names[1:len(self.names)-1]
    
    split2 = int( len(pairs) / len(self.names) )
    final_list = list(divide_chunks(pairs, split2 + 1))

    if self.cnt < (len(final_list)-1) :
      set_cnt()
      return final_list[self.cnt]
    else:
      self.cnt = 0
      return final_list[self.cnt]

'''Sample run

nl = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']
letters = RoundRobin(nl)

for i in range( int(len(nl) - 1) ):
  print(letters.generate_round())

print('\n AFTER LOOP ENDS: ROUND ROBIN RESTARTS \n')
print(letters.generate_round())

OUTPUT: 

[('A', 'H'), ('B', 'G'), ('C', 'F'), ('D', 'E')]
[('A', 'G'), ('H', 'F'), ('B', 'E'), ('C', 'D')]
[('A', 'F'), ('G', 'E'), ('H', 'D'), ('B', 'C')]
[('A', 'E'), ('F', 'D'), ('G', 'C'), ('H', 'B')]
[('A', 'D'), ('E', 'C'), ('F', 'B'), ('G', 'H')]
[('A', 'C'), ('D', 'B'), ('E', 'H'), ('F', 'G')]
[('A', 'B'), ('C', 'H'), ('D', 'G'), ('E', 'F')]

 AFTER LOOP ENDS: ROUND ROBIN RESTARTS 

[('A', 'H'), ('B', 'G'), ('C', 'F'), ('D', 'E')]

'''